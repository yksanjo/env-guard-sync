#!/usr/bin/env node

import chalk from 'chalk';
import { Command } from 'commander';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { getConfig } from './commands/init.js';
import { initDb, all, get, exec } from './utils/database.js';
import { logAudit } from './utils/audit.js';
import { encrypt, decrypt, setMasterKey, generateSecret } from './utils/crypto.js';

const program = new Command();

program
  .name('envguard-sync')
  .description('Synchronize environment variables across systems');

/**
 * Export to .env file
 */
program
  .command('export')
  .description('Export environment to .env file')
  .argument('<env>', 'Environment name')
  .argument('[file]', 'Output file (.env)')
  .option('--secrets', 'Include secrets (unencrypted)')
  .action(async (envName, filePath, options) => {
    try {
      await initDb();
      
      const env = get('SELECT * FROM environments WHERE name = ?', [envName]);
      if (!env) {
        console.log(chalk.red(`✗ Environment "${envName}" not found`));
        process.exit(1);
      }
      
      const variables = all('SELECT * FROM variables WHERE environment_id = ?', [env.id]);
      
      let output = `# Generated by envguard-sync\n`;
      output += `# Environment: ${envName}\n`;
      output += `# Exported at: ${new Date().toISOString()}\n\n`;
      
      variables.forEach(v => {
        if (v.is_secret && !options.secrets) {
          output += `# ${v.key}=[SECRET]\n`;
        } else {
          output += `${v.key}=${v.value}\n`;
        }
      });
      
      const outputPath = filePath || `${envName}.env`;
      writeFileSync(outputPath, output);
      
      console.log(chalk.green(`✓ Exported ${variables.length} variables to ${outputPath}`));
      
    } catch (error) {
      console.error(chalk.red('✗ Error:'), error.message);
    }
  });

/**
 * Import from .env file
 */
program
  .command('import')
  .description('Import from .env file')
  .argument('<env>', 'Environment name')
  .argument('<file>', '.env file to import')
  .option('--overwrite', 'Overwrite existing variables')
  .action(async (envName, filePath, options) => {
    try {
      if (!existsSync(filePath)) {
        console.log(chalk.red(`✗ File "${filePath}" not found`));
        process.exit(1);
      }
      
      await initDb();
      
      const env = get('SELECT * FROM environments WHERE name = ?', [envName]);
      if (!env) {
        console.log(chalk.red(`✗ Environment "${envName}" not found`));
        process.exit(1);
      }
      
      const content = readFileSync(filePath, 'utf8');
      const lines = content.split('\n');
      
      let imported = 0;
      let skipped = 0;
      
      lines.forEach(line => {
        line = line.trim();
        if (!line || line.startsWith('#')) return;
        
        const equalIndex = line.indexOf('=');
        if (equalIndex === -1) return;
        
        const key = line.substring(0, equalIndex).trim();
        const value = line.substring(equalIndex + 1).trim();
        
        if (!key) return;
        
        const existing = get('SELECT * FROM variables WHERE environment_id = ? AND key = ?', [env.id, key]);
        
        if (existing && !options.overwrite) {
          skipped++;
          return;
        }
        
        const id = existing?.id || require('uuid').v4();
        
        if (existing) {
          exec('UPDATE variables SET value = ?, updated_at = datetime("now") WHERE id = ?', [value, id]);
        } else {
          exec('INSERT INTO variables (id, environment_id, key, value) VALUES (?, ?, ?, ?)', [id, env.id, key, value]);
        }
        
        imported++;
      });
      
      console.log(chalk.green(`✓ Imported ${imported} variables (${skipped} skipped)`));
      
    } catch (error) {
      console.error(chalk.red('✗ Error:'), error.message);
    }
  });

/**
 * Sync between environments
 */
program
  .command('sync')
  .description('Sync variables between environments')
  .argument('<source>', 'Source environment')
  .argument('<target>', 'Target environment')
  .option('--overwrite', 'Overwrite existing')
  .action(async (source, target, options) => {
    try {
      await initDb();
      
      const sourceEnv = get('SELECT * FROM environments WHERE name = ?', [source]);
      const targetEnv = get('SELECT * FROM environments WHERE name = ?', [target]);
      
      if (!sourceEnv) {
        console.log(chalk.red(`✗ Source "${source}" not found`));
        process.exit(1);
      }
      
      if (!targetEnv) {
        console.log(chalk.red(`✗ Target "${target}" not found`));
        process.exit(1);
      }
      
      const variables = all('SELECT * FROM variables WHERE environment_id = ?', [sourceEnv.id]);
      
      let synced = 0;
      
      variables.forEach(v => {
        const existing = get('SELECT * FROM variables WHERE environment_id = ? AND key = ?', [targetEnv.id, v.key]);
        
        if (existing && !options.overwrite) {
          return;
        }
        
        const id = existing?.id || require('uuid').v4();
        
        if (existing) {
          exec('UPDATE variables SET value = ?, updated_at = datetime("now") WHERE id = ?', [v.value, id]);
        } else {
          exec(
            `INSERT INTO variables (id, environment_id, key, value, is_secret, tags, description) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [id, targetEnv.id, v.key, v.value, v.is_secret, v.tags, v.description]
          );
        }
        
        synced++;
      });
      
      console.log(chalk.green(`✓ Synced ${synced} variables from "${source}" to "${target}"`));
      
    } catch (error) {
      console.error(chalk.red('✗ Error:'), error.message);
    }
  });

/**
 * Generate CI/CD snippet
 */
program
  .command('ci-generate')
  .description('Generate CI/CD pipeline snippet')
  .argument('<env>', 'Environment name')
  .option('--provider <provider>', 'CI provider (github, gitlab, jenkins)')
  .action(async (envName, options) => {
    const provider = options.provider || 'github';
    
    console.log(chalk.cyan(`\n# CI/CD snippet for ${envName}\n`));
    
    if (provider === 'github') {
      console.log(chalk.gray(`# Add to your GitHub Actions workflow:
- name: Load Environment Variables
  run: |
    echo "${{ secrets.ENV_${envName.toUpperCase().replace(/-/g, '_')} }}" > .env
    cat .env >> $GITHUB_ENV
`));
    } else if (provider === 'gitlab') {
      console.log(chalk.gray(`# Add to your GitLab CI pipeline:
load-env:
  script:
    - echo "$ENV_${envName.toUpperCase()}" > .env
`));
    } else {
      console.log(chalk.gray(`# Export environment variables:
export $(cat ${envName}.env | xargs)
`));
    }
  });

program.parse(process.argv);
